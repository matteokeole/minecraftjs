<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="assets/css/main.css">
		<!-- Avoid favicon requests/warnings in the console -->
		<link rel="icon" href="data:;base64,=">
		<style>
			body {
				display: flex;
				justify-content: center;
				background-color: #595645;
			}
		</style>
	</head>

	<body>
		<script src="indev/font.js"></script>
		<script src="indev/layer.js"></script>
		<script>
			/**
			 * Construct a new layer component
			 * @param {object}	component			Component data, such as:
			 * @param {string}	component.type		Component type
			 * @param {string}	component.id		Component identifier
			 * @param {array}	component.origin	Component position, [0] for X and [1] for Y
			 * @param {array}	component.size		Component size, [0] for width and [1] for height
			 * @param {string}	component.texture	Component texture source (starts at /assets/textures/)
			 * @param {array}	component.uv		Component texture offset, [0] for X and [1] for Y
			 * @param {boolean}	component.visible	Component visibility attribute, which the canvas uses to draw it or not
			 * @param {array}	component.slots		Component slots to be displayed (only for container types)
			 */
			function Component(component) {
				this.type = component.type;
				this.id = component.id;
				this.visible = component.visible !== undefined ? component.visible : true;
				this.origin = {
					x: component.origin ? component.origin[0] : 0,
					y: component.origin ? component.origin[1] : 0,
				};
				this.size = {
					x: component.size ? component.size[0] : 0,
					y: component.size ? component.size[1] : 0,
				};
				this.texture = component.texture;
				this.uv = {
					x: component.uv ? component.uv[0] : 0,
					y: component.uv ? component.uv[1] : 0,
				};
				this.slots = this.type === "container" ? component.slots : undefined;

				this.setPosition = pos => {
					this.origin.x = pos[0];
					this.origin.y = pos[1];
				};
				this.toggle = (state = !this.visible) => {
					this.visible = state;
					if (this.type === "container" && this.slots) {
						for (let section of Object.values(this.slots)) {
							for (let slot of section) {
								slot.element.style.visibility = this.visible ? "visible" : "hidden";
							}
						}
					}
					this.layer.update();
				};

				switch (this.type) {
					case "text":
						this.text = component.text;
						this.text_align = component.text_align;
						this.text_size = component.text_size;
						this.text_color = component.text_color;

						break;
				}

				for (let section in this.slots) {
					for (let slot of this.slots[section]) {
						document.querySelector(".slots").append(slot.element);
					}
				}

				return this;
			}



			const
				Player = {
					maxHealth: 20,
					health: 17,
					maxHunger: 20,
					hunger: 19,
				},
				HUDLayer = new Layer({
					name: "hud",
					visible: 1,
				})
				.add(
					new Component({
						id: "crosshair",
						origin: [0, 0],
						size: [18, 18],
						texture: "gui/icons.png",
						uv: [3, 3],
					}),
				)
				.add(
					new Component({
						type: "container",
						id: "hotbar",
						origin: [0, -(window.innerHeight / 2) + 21],
						size: [364, 44],
						texture: "gui/widgets.png",
						uv: [0, 0],
					}),
				)
				.add(
					new Component({
						id: "selector",
						origin: [-160, -(window.innerHeight / 2) + 21],
						size: [48, 48],
						texture: "gui/widgets.png",
						uv: [0, 22],
					}),
				)
				.add(
					new Component({
						id: "experience_bar",
						origin: [0, -(window.innerHeight / 2) + 52],
						size: [364, 10],
						texture: "gui/icons.png",
						uv: [0, 64],
					}),
				)
				.add(
					new Component({
						type: "text",
						id: "tooltip",
						origin: [0, -(window.innerHeight / 2) + 108],
						texture: "font/ascii.png",
						text: "Orange Tulip",
						text_align: "center",
						text_size: 20,
						text_color: "#FFF",
					}),
				);

			// Heart outlines
			for (let i = 0; i < Player.maxHealth / 2; i++) {
				HUDLayer
					.add(
						new Component({
							id: `heart_outline_${i}`,
							origin: [
								-173 + (i % 10) * 16,
								-(window.innerHeight / 2) + Math.floor(i / 10) * 20 + 68,
							],
							size: [18, 18],
							texture: "gui/icons.png",
							uv: [16, 0],
						}),
					);
			}

			// Heart inners
			let j = 0;
			for (let i = 0; i < Player.health; i++) {
				// Add half-heart if health value is odd
				if (Player.health % 2 !== 0 && i + 1 === Player.health) {
					j = i / 2;
					HUDLayer
						.add(
							new Component({
								id: `heart_inner_${j}`,
								origin: [
									-172 + (j % 10) * 16,
									-(window.innerHeight / 2) + Math.floor(j / 10) * 20 + 68,
								],
								size: [16, 14],
								texture: "gui/icons.png",
								uv: [62, 1],
							}),
						);
					break;
				}
				else if (i % 2 === 0) {
					j = i / 2;
					HUDLayer
						.add(
							new Component({
								id: `heart_inner_${j}`,
								origin: [
									-172 + (j % 10) * 16,
									-(window.innerHeight / 2) + Math.floor(j / 10) * 20 + 68,
								],
								size: [16, 14],
								texture: "gui/icons.png",
								uv: [53, 1],
							}),
						);
				}
			}

			// Hunger outlines
			for (let i = 0; i < Player.maxHunger / 2; i++) {
				HUDLayer
					.add(
						new Component({
							id: `hunger_outline_${i}`,
							origin: [
								173 - (i % 10) * 16,
								-(window.innerHeight / 2) + Math.floor(i / 10) * 20 + 68,
							],
							size: [18, 18],
							texture: "gui/icons.png",
							uv: [16, 27],
						}),
					);
			}

			// Hunger inners
			j = 0;
			for (let i = 0; i < Player.hunger; i++) {
				// Add half-hunger if hunger value is odd
				if (Player.hunger % 2 !== 0 && i + 1 === Player.hunger) {
					j = i / 2;
					HUDLayer
						.add(
							new Component({
								id: `hunger_inner_${j}`,
								origin: [
									174 - (j % 10) * 16,
									-(window.innerHeight / 2) + Math.floor(j / 10) * 20 + 69,
								],
								size: [16, 16],
								texture: "gui/icons.png",
								uv: [62, 27],
							}),
						);
				}
				else if (i % 2 === 0) {
					j = i / 2;
					HUDLayer
						.add(
							new Component({
								id: `hunger_inner_${j}`,
								origin: [
									174 - (j % 10) * 16,
									-(window.innerHeight / 2) + Math.floor(j / 10) * 20 + 69,
								],
								size: [16, 16],
								texture: "gui/icons.png",
								uv: [53, 27],
							}),
						);
				}
			}

			/*for (let i = 0; i < 10; i++) {
				HUDLayer
					.add(
						new Component({
							id: `armor_outline_${i}`,
							origin: [
								-173 + (i % 10) * 16,
								-(window.innerHeight / 2) + Math.floor(i / 10) * 20 + 88,
							],
							size: [18, 18],
							texture: "gui/icons.png",
							uv: [16, 9],
						}),
					)
					.add(
						new Component({
							id: `armor_inner_${i}`,
							origin: [
								-172 + (i % 10) * 16,
								-(window.innerHeight / 2) + Math.floor(i / 10) * 20 + 90,
							],
							size: [16, 14],
							texture: "gui/icons.png",
							uv: [44, 9],
						}),
					)
					.add(
						new Component({
							id: `bubble_outline_${i}`,
							origin: [
								173 - (i % 10) * 16,
								-(window.innerHeight / 2) + Math.floor(i / 10) * 20 + 88,
							],
							size: [18, 18],
							texture: "gui/icons.png",
							uv: [16, 18],
						}),
					);
			}*/

			let
				selected_slot = 0,
				hotbar_slots = [
					"Digit1",
					"Digit2",
					"Digit3",
					"Digit4",
					"Digit5",
					"Digit6",
					"Digit7",
					"Digit8",
					"Digit9",
				],
				canSwitchSlot = true,
				isSlotKey = false;
				c = HUDLayer.components;

			HUDLayer.update();

			addEventListener("keydown", e => {
				if (!/^(ControlLeft|F\d+)$/.test(e.code)) e.preventDefault();
				if (canSwitchSlot) {
					isSlotKey = false;
					canSwitchSlot = false;
					let prev_slot = selected_slot;

					if (e.code === "F1") HUDLayer.toggle();

					for (let i in hotbar_slots) {
						if (e.code === hotbar_slots[i]) {
							isSlotKey = true;
							selected_slot = e.code.charAt(e.code.length - 1) - 1;
						}
					}

					if (isSlotKey) {
						// Clear the previous selected slot
						HUDLayer.ctx.clearRect(
							(HUDLayer.canvas.width / 2) - (c.selector.size.x / 2) + c.selector.origin.x + (prev_slot * (c.selector.size.x - 8)),
							(HUDLayer.canvas.height / 2) - (c.selector.size.y / 2) - c.selector.origin.y,
							c.selector.size.x + 2,
							c.selector.size.y,
						);

						// Re-draw the hotbar part where the selector was
						HUDLayer.ctx.drawImage(
							HUDLayer.loadedTextures[HUDLayer.components.hotbar.texture],
							c.hotbar.uv.x - (prev_slot * c.selector.origin.x / 8) - 1,
							c.hotbar.uv.y,
							c.hotbar.size.x / 16 + 2,
							c.hotbar.size.y / 2,
							(HUDLayer.canvas.width / 2) - (c.hotbar.size.x / 2) + c.hotbar.origin.x - (prev_slot * c.selector.origin.x / 4) - 2,
							(HUDLayer.canvas.height / 2) - (c.hotbar.size.y / 2) - c.hotbar.origin.y,
							c.selector.size.x + 2,
							c.selector.size.y - 4,
						);

						// Re-draw the selector on the new selected slot
						HUDLayer.ctx.drawImage(
							HUDLayer.loadedTextures[HUDLayer.components.selector.texture],
							c.selector.uv.x,
							c.selector.uv.y,
							c.selector.size.x / 2,
							c.selector.size.y / 2,
							(HUDLayer.canvas.width / 2) - (c.selector.size.x / 2) + c.selector.origin.x - (selected_slot * c.selector.origin.x / 4),
							(HUDLayer.canvas.height / 2) - (c.selector.size.y / 2) - c.selector.origin.y,
							c.selector.size.x,
							c.selector.size.y,
						);
					}
				}
			});
			addEventListener("keyup", () => canSwitchSlot = true);
			addEventListener("wheel", e => {
				// Clear the previous selected slot
				HUDLayer.ctx.clearRect(
					(HUDLayer.canvas.width / 2) - (c.selector.size.x / 2) + c.selector.origin.x + (selected_slot * (c.selector.size.x - 8)),
					(HUDLayer.canvas.height / 2) - (c.selector.size.y / 2) - c.selector.origin.y,
					c.selector.size.x + 2,
					c.selector.size.y,
				);

				// Re-draw the hotbar part where the selector was
				HUDLayer.ctx.drawImage(
					HUDLayer.loadedTextures[HUDLayer.components.hotbar.texture],
					c.hotbar.uv.x - (selected_slot * c.selector.origin.x / 8) - 1,
					c.hotbar.uv.y,
					c.hotbar.size.x / 16 + 2,
					c.hotbar.size.y / 2,
					(HUDLayer.canvas.width / 2) - (c.hotbar.size.x / 2) + c.hotbar.origin.x - (selected_slot * c.selector.origin.x / 4) - 2,
					(HUDLayer.canvas.height / 2) - (c.hotbar.size.y / 2) - c.hotbar.origin.y,
					c.selector.size.x + 2,
					c.selector.size.y - 4,
				);

				// Increment/decrement selector based on wheel direction
				selected_slot = e.deltaY > 0 ? (selected_slot < 8 ? ++selected_slot : 0) : (selected_slot > 0 ? --selected_slot : 8);

				// Re-draw the selector on the new selected slot
				HUDLayer.ctx.drawImage(
					HUDLayer.loadedTextures[HUDLayer.components.selector.texture],
					c.selector.uv.x,
					c.selector.uv.y,
					c.selector.size.x / 2,
					c.selector.size.y / 2,
					(HUDLayer.canvas.width / 2) - (c.selector.size.x / 2) + c.selector.origin.x - (selected_slot * c.selector.origin.x / 4),
					(HUDLayer.canvas.height / 2) - (c.selector.size.y / 2) - c.selector.origin.y,
					c.selector.size.x,
					c.selector.size.y,
				);
			});
		</script>
	</body>
</html>